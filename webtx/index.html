<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BLE RC Web Controller</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="top-bar">
    <button onclick="connect()" id="connectBtn">Connect</button>
    <button onclick="disconnect()" id="disconnectBtn" disabled>Disconnect</button>
    <span id="battery">Battery: --%</span>
    <button id="moreBtn" onclick="toggleExtras()">More...</button>
    <div id="extras" style="display:none;">
      <button onclick="resetToDFU()">Reset to DFU</button>
      <button onclick="setName()">Set name</button>
    </div>
  </div>
  <h1 style="text-align:center; margin-top:20px;">BLE RC Web Controller</h1>
  <div class="main-content">
    <canvas id="joystick" width="300" height="300"></canvas>
    <div class="controls">
      <label><input type="checkbox" onchange="toggleLight(this, 'H')" id="headlightCheck"> Headlights</label>
      <label><input type="checkbox" onchange="toggleLight(this, 'M')" id="markerlightCheck"> Marker lights</label>
      <label><input type="checkbox" onchange="toggleLight(this, 'E')" id="hazardlightCheck"> Hazard lights</label>
    </div>
  </div>
  <div id="log"></div>
  <script>
    const nusServiceUUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const txCharUUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const rxCharUUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
    const batteryServiceUUID = 'battery_service';
    const batteryCharUUID = 'battery_level';

    let txCharacteristic = null;
    let rxCharacteristic = null;
    let device = null;
    let batteryChar = null;

    // Gamepad state variables
    let gamepadIndex = null;
    let gamepadInterval = null;
    let prevButtonStates = [];


    function log(message) {
      const logDiv = document.getElementById('log');
      logDiv.textContent += message + '\n';
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    async function connect() {
      document.getElementById('connectBtn').disabled = true; // Disable immediately
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [nusServiceUUID] }],
          optionalServices: [batteryServiceUUID]
        });

        device.addEventListener('gattserverdisconnected', onDisconnected);

        const server = await device.gatt.connect();
        const nusService = await server.getPrimaryService(nusServiceUUID);
        txCharacteristic = await nusService.getCharacteristic(txCharUUID);
        rxCharacteristic = await nusService.getCharacteristic(rxCharUUID);

        rxCharacteristic.startNotifications();
        rxCharacteristic.addEventListener('characteristicvaluechanged', event => {
          const decoder = new TextDecoder();
          const value = decoder.decode(event.target.value);
          log('Received: ' + value);
        });

        try {
            const batteryService = await server.getPrimaryService(batteryServiceUUID);
            batteryChar = await batteryService.getCharacteristic(batteryCharUUID);
            updateBatteryLevel();

            await batteryChar.startNotifications();
            batteryChar.addEventListener('characteristicvaluechanged', updateBatteryLevel);
        } catch (error) {
            log('Battery service not found. Skipping.');
        }


        document.getElementById('disconnectBtn').disabled = false;

        log('Connected to device');
      } catch (error) {
        console.error('Bluetooth connection failed:', error);
        log('Connection failed. Make sure the device is in range and supports the required services.');
        document.getElementById('connectBtn').disabled = false; // Re-enable on failure
      }
    }

    function disconnect() {
      if (device && device.gatt.connected) {
        device.gatt.disconnect();
      }
    }

    function updateBatteryLevel(event) {
      let value;
      if (event && event.target?.value) {
        value = event.target.value.getUint8(0);
      } else if (batteryChar) {
        batteryChar.readValue().then(val => {
          document.getElementById('battery').textContent = `Battery: ${val.getUint8(0)}%`;
        }).catch(err => log('Could not read battery level.'));
        return;
      }
      if (typeof value === 'number') {
        document.getElementById('battery').textContent = `Battery: ${value}%`;
      }
    }

    function onDisconnected(event) {
      log('Device disconnected');
      txCharacteristic = null;
      document.getElementById('battery').textContent = 'Battery: --%';
      document.getElementById('connectBtn').disabled = false;
      document.getElementById('disconnectBtn').disabled = true;
    }

    function sendCommand(command) {
      if (!txCharacteristic) {
        // Silently fail if not connected, to avoid flooding the log
        return;
      }
      try {
        const encoder = new TextEncoder();
        txCharacteristic.writeValueWithoutResponse(encoder.encode(command));
        // log('Sent: ' + command.trim()); // Logging removed to prevent flooding from gamepad
      } catch (error) {
        console.error('Failed to send command:', error);
        log('Error sending command: ' + error);
      }
    }

    function toggleLight(checkbox, type) {
      const value = checkbox.checked ? 127 : 0;
      sendCommand(`${type}=${value}\n`);
      log(`Toggled ${type} light ${checkbox.checked ? 'ON' : 'OFF'}`);
    }

    function toggleExtras() {
      const extras = document.getElementById('extras');
      extras.style.display = extras.style.display === 'none' ? 'block' : 'none';
    }

    function resetToDFU() {
      sendCommand('!dfu\n');
    }

    function setName() {
      const current = (device && device.name) ? device.name : '';
      const promptName = 'Enter new device name:';
      const name = prompt(promptName, current);
      if (name && name.trim()) {
        sendCommand(`!name=${name.trim()}\n`);
      }
    }

    const canvas = document.getElementById('joystick');
    const ctx = canvas.getContext('2d');
    let center = { x: canvas.width / 2, y: canvas.height / 2 };

    function resizeJoystick() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      center = { x: canvas.width / 2, y: canvas.height / 2 };
      drawJoystick(center.x, center.y);
    }

    function drawJoystick(x, y) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const radius = Math.min(canvas.width, canvas.height) * 0.45;
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = '#aaa';
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.14, 0, Math.PI * 2);
      ctx.fillStyle = '#007bff';
      ctx.fill();
    }

    function handleJoystick(x, y) {
      drawJoystick(x, y);
      const dx = x - center.x;
      const dy = y - center.y;
      const max = Math.min(canvas.width, canvas.height) * 0.45;
      const d = Math.max(-127, Math.min(127, -Math.round(dy / max * 127)));
      const s = Math.max(-127, Math.min(127, Math.round(dx / max * 127)));
      sendCommand(`D=${d}\nS=${s}\n`);
    }

    function getTouchPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const touch = evt.touches[0];
      return {
        x: (touch.clientX - rect.left),
        y: (touch.clientY - rect.top)
      };
    }

    canvas.addEventListener('mousedown', evt => {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      handleJoystick(x, y);
      const moveHandler = moveEvt => {
        const mx = moveEvt.clientX - rect.left;
        const my = moveEvt.clientY - rect.top;
        handleJoystick(mx, my);
      };
      const upHandler = () => {
        handleJoystick(center.x, center.y);
        window.removeEventListener('mousemove', moveHandler);
        window.removeEventListener('mouseup', upHandler);
      };
      window.addEventListener('mousemove', moveHandler);
      window.addEventListener('mouseup', upHandler);
    });

    canvas.addEventListener('touchstart', evt => {
      evt.preventDefault();
      const pos = getTouchPos(evt);
      handleJoystick(pos.x, pos.y);
    }, { passive: false });
    canvas.addEventListener('touchmove', evt => {
      evt.preventDefault();
      const pos = getTouchPos(evt);
      handleJoystick(pos.x, pos.y);
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
      handleJoystick(center.x, center.y);
    });

    // --- Gamepad API Integration ---

    function pollGamepad() {
        if (gamepadIndex === null) return;
        const gamepad = navigator.getGamepads()[gamepadIndex];
        if (!gamepad) return;

        // Axes
        let axisX = gamepad.axes[0];
        let axisY = gamepad.axes[1];
        const deadzone = 0.1;

        // --- Use B6-B7 difference for Y axis override ---
        // B6: gamepad.buttons[6], B7: gamepad.buttons[7]
        if (gamepad.buttons.length >= 8) {
            const b6 = gamepad.buttons[6].value || (gamepad.buttons[6].pressed ? 1 : 0);
            const b7 = gamepad.buttons[7].value || (gamepad.buttons[7].pressed ? 1 : 0);
            // If either is pressed, override axisY
            if (b6 !== 0 || b7 !== 0) {
                axisY = b6 - b7; // Range: -1 (B7) to +1 (B6)
            }
        }

        if (Math.abs(axisX) < deadzone) axisX = 0;
        if (Math.abs(axisY) < deadzone) axisY = 0;

        const max = Math.min(canvas.width, canvas.height) * 0.45;
        const jX = center.x + axisX * max;
        const jY = center.y + axisY * max;
        drawJoystick(jX, jY);

        const d = Math.max(-127, Math.min(127, -Math.round(axisY * 127)));
        const s = Math.max(-127, Math.min(127, Math.round(axisX * 127)));
        sendCommand(`D=${d}\nS=${s}\n`);

        // Buttons
        const lightCheckboxes = [
            document.getElementById('headlightCheck'),
            document.getElementById('markerlightCheck'),
            document.getElementById('hazardlightCheck')
        ];

        gamepad.buttons.slice(0, 3).forEach((button, index) => {
            if (button.pressed && !prevButtonStates[index]) {
                lightCheckboxes[index].click(); // Triggers onchange event and toggleLight function
            }
            prevButtonStates[index] = button.pressed;
        });
    }

    window.addEventListener('gamepadconnected', (event) => {
        log(`Gamepad connected: ${event.gamepad.id}`);
        gamepadIndex = event.gamepad.index;
        // Initialize button states
        prevButtonStates = navigator.getGamepads()[gamepadIndex].buttons.map(b => b.pressed);

        if (gamepadInterval) {
            clearInterval(gamepadInterval);
        }
        gamepadInterval = setInterval(pollGamepad, 50); // Poll 20 times per second
    });

    window.addEventListener('gamepaddisconnected', (event) => {
        if (gamepadIndex === event.gamepad.index) {
            log('Gamepad disconnected.');
            clearInterval(gamepadInterval);
            gamepadInterval = null;
            gamepadIndex = null;
            handleJoystick(center.x, center.y); // Reset joystick to center
        }
    });


    // Initial setup
    window.addEventListener('resize', resizeJoystick);
    window.addEventListener('orientationchange', resizeJoystick);
    resizeJoystick();

  </script>
</body>
</html>
